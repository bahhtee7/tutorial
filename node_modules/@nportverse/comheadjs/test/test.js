'use strict';

const net = require('net');

const {
	client_proxy_t,
	server_proxy_t
} = require('../index');

const XOR=1111;

class server_t extends net.Server {
	constructor()
	{
		super(c => {
			this.add_client(c);
		});

		this.on('error', e => {
			throw e;
		});

		this.clients = new Set();
	}

	add_client(c)
	{
		const client = new client_proxy_t(c, XOR);
		this.clients.add(client);

		client.on('req', async (c, packet, payload) => {
			if (!this.clients.has(c)) {
			}

			try {
				// echo
				await c.send(packet.tr_code, packet.req_id, payload);
			}
			catch (e) {
				console.error(e);
				return;
			}
		});

		client.on('unavailable', (c) => {
			this.rm_client(c);
		});
	}

	rm_client(c)
	{
		this.clients.delete(c);
	}

	// https://github.com/gajus/http-terminator/blob/master/src/factories/createInternalHttpTerminator.ts
	close()
	{
		// N.B., we don't implement funtion to prevent new connections. 
		for (const c of this.clients) {
			c.destroy();
		}
		super.close();
	}
}

const server = new server_t();

server.on('listening', async () => {
	const conn = new server_proxy_t('localhost', 9999, XOR);
	await conn.connect();

	const resp = await conn.call({
		tr_code: '1111',
		arg1: 'arg1',
		arg2: 'arg2'
	});

	console.dir(resp);

	//conn.destroy();
	server.close();
});

server.listen(9999);
