'use strict';

const dump = require('buffer-hexdump');

class transport_header_t {
	constructor(paylen)
	{
		this.paylen = paylen;
	}

	static depktize(buf)
	{
		//console.log('XXX', buf, buf.length);
		if (buf.length < this.SZ) {
			return false;
		}

		if (String.fromCharCode(buf[0]) != 'L') {
			throw new Error('Invalid endianess');
		}

		const paylen = buf.readUInt32LE(packet_t.PKTLEN_I);

		return new transport_header_t(paylen);
	}

	pktize()
	{
		let cur = 0;
		const header = Buffer.alloc(this.constructor.SZ);

		// endianess
		header.write('L', cur++);
		header.writeUInt32LE(this.paylen, cur);

		return header;
	}

	pkt_size()
	{
		return this.constructor.SZ + this.paylen;
	}
}

transport_header_t.SZ = 5;


class packet_t {
	constructor(buf)
	{
		if (Number.isInteger(buf)) {
			this.buf = Buffer.alloc(buf);
		} 
		else {
			this.buf = Buffer.from(buf);
		}
	}

	size()
	{
		return this.buf.length;
	}

	static depktize(buf)
	{
		//console.log(dump(buf));

		//let cur = 0;
		const theader = transport_header_t.depktize(
			buf.slice(0, transport_header_t.SZ)
		);

		//cur += transport_header_t.SZ;

		// TODO: size check
		if ( !theader
		  || buf.length < theader.pkt_size())
		{
			return false;
		}

		//console.log('pkt size', theader.pkt_size());
		//console.log('pkt size', theader.pkt_size().toString(16));

		const rv = new packet_t(buf.slice(0, theader.pkt_size()));
		rv.parse();
		return rv;
	}

	parse()
	{
		//console.log('<<<<<<<<<<<<<<<');
		//console.log(dump(this.buf));
		//console.log('>>>>>>>>>>>>>>>');

		this.tr_code = this.buf.readInt32LE(packet_t.TRCODE_I);
		this.err_code = this.buf.readInt32LE(packet_t.ERROR_I);

		this.sym_code = this.buf.readInt32LE(packet_t.SYM_CODE_I);

		// trim() doesn't remove '\0';
		this.req_id = this.buf.slice(
				packet_t.REQID_I,
				packet_t.REQID_I + packet_t.REQID_SZ
				).toString().replace(/\0/g, '').trim();

		//const req_id = this.buf.slice(packet_t.REQID_I, packet_t.REQID_I+packet_t.REQID_SZ);
		//console.log(req_id.toString().trim().length);

		const data_len = this.buf.readUInt32LE(packet_t.PAYLEN_I);
		//const payload = Buffer.alloc(data_len);

//		this.payload = Buffer.from(
//			this.buf.slice(
//				packet_t.PAYLOAD_I,
//				packet_t.PAYLOAD_I + data_len
//			)
//		);

		this.header = this.buf.slice(0, packet_t.PAYLOAD_I);

		this.payload = this.buf.slice(
				packet_t.PAYLOAD_I,
				packet_t.PAYLOAD_I + data_len
				);

	}

	// for some idiosyncratic servers
	update_header(header)
	{
		if (!header) return;

		if (header instanceof Function) {
			return header(this)
		}

		if (Buffer.isBuffer(header)) {
			// 요청 들어왔던 HEADER 데이터값 PACKET 크기만 변경하여 그대로 전달
			const pkt_len = packet_t.HEADER_SZ + this.payload.length + packet_t.TAIL_SZ;

			// update packet length
			header.writeUInt32LE(pkt_len, packet_t.PKTLEN_I);
			header.copy(this.buf, 0, 0, packet_t.PAYLOAD_I - 1);
		}
	}

	static pktize(tr_code, req_id, payloadOrError, header)
	{
		tr_code = Number(tr_code);

		let client_ip = '';

		let _pktize;
		if (Buffer.isBuffer(payloadOrError)) {
			_pktize = this.pktize_normal;
		}
		else if (Number.isInteger(payloadOrError)) {
			_pktize = this.pktize_error;
		}
		else if (typeof payloadOrError === 'object') {
			client_ip = payloadOrError.clientIp || '';
			delete payloadOrError.clientIp;
			
			payloadOrError = Buffer.from(JSON.stringify(payloadOrError));
			_pktize = this.pktize_normal;
			

		}
		else {
			throw new Error('Invalid arg');
		}

		return _pktize(tr_code, req_id, payloadOrError, header, client_ip);
	}

	// XXX: refactoring
	static pktize_normal(tr_code, req_id, payload, header, client_ip='')
	{
		const paylen = payload.length;

		const pkt_len = packet_t.HEADER_SZ + paylen + packet_t.TAIL_SZ;

		const theader = new transport_header_t(pkt_len);

		const rv = new packet_t(pkt_len + transport_header_t.SZ);

		theader.pktize().copy(rv.buf);

		rv.buf.write('E', packet_t.VER_I);
		rv.buf.write('H', packet_t.CTYPE_I);

		rv.tr_code = tr_code;
		rv.buf.writeInt32LE(tr_code, packet_t.TRCODE_I);

		rv.err_code = 0;

		rv.buf.writeUInt32LE(paylen, packet_t.PAYLEN_I);

		
		
		rv.req_id = req_id.trim();
		req_id = req_id.padStart(packet_t.REQID_SZ, "\0");
		//console.log('req_id', `"${req_id}"`, req_id.length);
		//console.log(dump(Buffer.from(req_id)));
		rv.buf.write(req_id, packet_t.REQID_I);

		
		client_ip = client_ip.padEnd(packet_t.CIP_SZ,"\0");
		rv.buf.write(client_ip, packet_t.CIP_I);

		payload.copy(rv.buf, packet_t.PAYLOAD_I);
		rv.payload = payload;

		rv.update_header(header)

		// TAIL
		rv.buf.write(packet_t.TAIL, packet_t.PAYLOAD_I + payload.length);

		return rv;
	}

	static pktize_error(tr_code, req_id, err_code, header)
	{
		const paylen = 0;

		const pkt_len = packet_t.HEADER_SZ + paylen + packet_t.TAIL_SZ;

		const theader = new transport_header_t(pkt_len);

		const rv = new packet_t(pkt_len + transport_header_t.SZ);

		theader.pktize().copy(rv.buf);

		rv.buf.write('E', packet_t.VER_I);
		rv.buf.write('H', packet_t.CTYPE_I);

		rv.tr_code = tr_code;
		rv.buf.writeInt32LE(tr_code, packet_t.TRCODE_I);

		//this.err_code = this.buf.readInt32LE(packet_t.ERROR_I);
		rv.buf.writeInt32LE(err_code, packet_t.ERROR_I);
		rv.err_code = err_code;

		rv.buf.writeUInt32LE(paylen, packet_t.PAYLEN_I);

		rv.req_id = req_id.trim();
		req_id = req_id.padStart(packet_t.REQID_SZ, "\0");
		rv.buf.write(req_id, packet_t.REQID_I);

		rv.payload = Buffer.alloc(0);

		rv.update_header(header)

		// TAIL
		rv.buf.write(packet_t.TAIL, packet_t.PAYLOAD_I + err_code.length);

		return rv;
	}

};

packet_t.PKTLEN_I = 1;

packet_t.VER_I = 7;
packet_t.CTYPE_I = 8;

packet_t.TRCODE_I = 9;
packet_t.ERROR_I = 13;
packet_t.PAYLEN_I = 17;
packet_t.SYM_CODE_I = 29;
packet_t.REQID_I = 34;
packet_t.CIP_I = 90;
packet_t.PAYLOAD_I = 154;

packet_t.HEADER_SZ = 149;
packet_t.REQID_SZ = 32;
packet_t.CIP_SZ = 16;
packet_t.TAIL_SZ = 4;
packet_t.TAIL = "\0EOP";


module.exports = packet_t;


if (require.main === module) {
//	const th = new transport_header_t(10);
//	console.log(th.pktize());
//	console.log(th.pkt_size());

	packet_t.depktize(Buffer.alloc(4));
}
