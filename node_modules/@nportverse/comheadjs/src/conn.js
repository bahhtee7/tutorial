'use strict';

const net = require('net');
const EventEmitter = require('events');

const packet_t = require('./packet');

const aes_dec = require('./aes_dec');

class conn_t extends EventEmitter {
	constructor(sock, xor)
	{
		super();

		this.sock = sock || new net.Socket();

		this._init();

		if (Number.isInteger(xor)) {
			this.xor = xor;
		}
		else {
			this.xor = Number(aes_dec(xor, 'funnyfig')); 
		}
	}

	destroy()
	{
		this.sock.destroy();
	}

	async send(tr_code, req_id, payloadOrError, header)
	{
		const pkt = packet_t.pktize(tr_code, req_id, payloadOrError, header);
		return await this.write(pkt.buf);
	}

	_init()
	{
		this.ibuf = Buffer.alloc(0);

		this.sock.on('data', data => {
			// TODO: improve
			this.ibuf = Buffer.concat([this.ibuf, data]);

			while (this._proc_idata());
		});

		this.sock.on('error', e => {
			this.sock.destroy();
			this.emit('error', e);
		});

		this.sock.on('end', () => {
			this.sock.destroy();
			this.emit('end');
		});

		this.sock.on('close', () => {
			this.sock.destroy();
			this.emit('close');
		});
	}

//	_write(data, cb)
//	{
//		if (this.sock.write(data)) {
//			return cb();
//		}
//
//		this.sock.once('drain', () => {
//			this._write(data, cb);
//		});
//	}

//	_write(data, resolve, reject)
//	{
//		if (this.sock.write(data, null, e => {
//			if (e) {
//				return reject(e);
//			}
//			resolve();
//		}))
//		{
//			return;
//		}
//
//		this.sock.once('drain', () => {
//			this._write(data, resolve, reject);
//		});
//	}

	_write(data, resolve, reject)
	{
		if (this.sock.write(data, null, e => {
			if (e) {
				return reject(e);
			}
			resolve();
		}))
		{
			return;
		}

		this.sock.once('drain', () => {
			resolve();
		});
	}




	async write(data)
	{
		return new Promise((resolve, reject) => {
			this._write(data, resolve, reject);
		});
	}

	// override! just eat up
	_proc_idata()
	{
		this.ibuf = Buffer.alloc(0);
		console.error('_proc_idata() should be override');
		return true;
	}
}

module.exports = conn_t;

