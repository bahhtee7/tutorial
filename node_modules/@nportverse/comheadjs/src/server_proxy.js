'use strict';

const net = require('net');

const {nanoid} = require('nanoid');
//const dump = require('buffer-hexdump');

const conn_t = require('./conn');
const { challenge_response } = require('./handshake');
const packet_t = require('./packet');

//const aes_dec = require('./aes_dec');

class server_proxy_t extends conn_t {
	constructor(url, port, xor)
	{
		super(null, xor);

		this.url = url;
		this.port = port;

//		if (Number.isInteger(xor)) {
//			this.xor = xor;
//		}
//		else {
//			this.xor = Number(aes_dec(xor, 'funnyfig')); 
//		}

		this.state = 'unavailable';

		// outside should know know socket unavailable
		// reconnect
		this.on('close', () => {
			this.state = 'unavailable';
			this.emit('unavailable', this);
			this._uninit();
			this._init();
			setTimeout(() => {
				this.connect();
			}, 2000);
		});

		this.on('error', e => {
			this.state = 'unavailable';
			console.error(e);
			this.emit('unavailable', this);
		});

		this.on('end', () => {
			this.state = 'unavailable';
			this.emit('unavailable', this);
		});

		this.on('challenge', packet => {
			this._challenge(packet);
		});

		this.on('chal_result', packet => {
			this._chal_result(packet);
		});

		this.on('resp', packet => {
			this._return(packet);
		});
	}

	async connect()
	{
		//if (this.sock.connecting) return;

		console.log('connect()');

		return new Promise(resolve => {
			this.sock.connect(this.port, this.url);
			this.once('available', resolve);
		});
	}

//	async call(params)
//	{
//		// call one by one from backend server restriction
//		return new Promise((resolve, reject) => {
//			const req_id = nanoid(8);
//			this.send(params.tr_code, req_id, params);
//			this.reqs.set(req_id,{resolve, reject});
//		});
//	}

	async call(params, resolve, reject)
	{
		//console.log('call', params);

		if (resolve) {
			const req_id = nanoid(8);
			this.send(params.tr_code, req_id, params);
			// no reject
			this.reqs.set(req_id,{resolve, reject});
			return;
		}

		// call one by one from backend server restriction
		return new Promise((resolve, reject) => {
			const req_id = nanoid(8);
			this.send(params.tr_code, req_id, params);
			this.reqs.set(req_id,{resolve, reject});
		});
	}

	_return(packet)
	{
		//console.log('_return', packet);

		if (!this.reqs.has(packet.req_id)) {
			try {
				const resp = JSON.parse(packet.payload.toString());
				const sym_code = packet.sym_code? packet.sym_code.toString() : null;
				this.emit('notify', resp, sym_code);
			}
			catch (e) {
				// eatup
			}
			return;
		}
		const {resolve, reject} = this.reqs.get(packet.req_id);
		this.reqs.delete(packet.req_id);

		// unexpected
		if (!resolve) return;

		let resp = packet.payload.toString();
		try {
			resp = JSON.parse(resp);
		}
		catch (e) {
			reject('Invalid response');
		}

		resolve(resp);
	}

	_init()
	{
		if (!this.sock || this.sock.destroyed) {
			this.sock = new net.Socket();
		}

		this.reqs = new Map();

		this.resp_event = 'challenge';
		super._init();
	}

	_uninit()
	{
		// call pending requests
		// make failure
	}

	_proc_idata()
	{
		const pkt = packet_t.depktize(this.ibuf);
		if (!pkt) return false;

		this.emit(this.resp_event, pkt);

		this.ibuf = Buffer.from(this.ibuf.slice(pkt.size()));

		return true;
	}

	_challenge(packet)
	{
		//console.log('challenge 190 pkt');
		//console.log(dump(packet.buf));
		//console.log(dump(packet.payload));

		if (packet.tr_code != 190) {
			console.log('Invalid start code');
			return this.sock.destroy();
		}

		//this.send(191, packet.req_id, challenge_response(packet.payload));
		this.send(190, packet.req_id, challenge_response(packet.payload, this.xor));

		this.resp_event = 'chal_result';
	}

	_chal_result(packet)
	{
		if (packet.tr_code != 191) {
			console.log('Invalid start response', packet.tr_code);
			return this.sock.destroy();
		}

		this.resp_event = 'resp';

		this.state = 'available';
		this.emit('available', this);
		
		console.log('backend connected');
	}
}

module.exports = server_proxy_t;

if (require.main === module) {
(async () => {
	const client = new server_proxy_t('192.168.0.120', 17527);

	await client.connect();

	let resp;
	resp = await client.call({
		tr_code: '4500',
		'x-user-ci': 'NTQ2MTg5ODk5MQo=',
		'x-api-tran-id': 'APITRANID',
		org_code: '00org8code',
		ci_code: '01'
	});

	console.log(resp);
})();
}
